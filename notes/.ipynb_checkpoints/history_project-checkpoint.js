{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "660bb7b3",
   "metadata": {},
   "source": [
    "//WHERE WE ARE AT IN THE PROJECT // CONDENSE THIS INFO GREATLY AS IT'S ONLY TO GUIDE YOU WHERE WE ARE\n",
    "Fantastic! It sounds like you're already off to a great start. Let's continue with step 4 then.\n",
    "\n",
    "Design Visual Decision Tree:\n",
    "\n",
    "A library like vis.js can be very useful for creating interactive, dynamic network diagrams that could serve as your decision tree. However, it's worth noting that vis.js is a JavaScript library, and using it directly in a Jupyter Notebook running with an iJavascript kernel might have its challenges, as the notebook environment isn't designed to handle complex web visualizations.\n",
    "\n",
    "Here's a basic example of how you might start creating a network diagram with vis.js:\n",
    "\n",
    "javascript Copy code var nodes = [ {id: 1, label: 'Node 1'}, {id: 2, label: 'Node 2'}, {id: 3, label: 'Node 3'}, {id: 4, label: 'Node 4'}, {id: 5, label: 'Node 5'} ];\n",
    "\n",
    "// create an array with edges var edges = [ {from: 1, to: 2}, {from: 1, to: 3}, {from: 2, to: 4}, {from: 2, to: 5} ];\n",
    "\n",
    "// create a network var container = document.getElementById('mynetwork'); var data = { nodes: nodes, edges: edges }; var options = {}; var network = new vis.Network(container, data, options); In this example, you'd need to replace the static nodes and edges with dynamic ones based on the responses from the chatbot.\n",
    "\n",
    "However, it's important to consider that running this kind of JavaScript code might not work in a Jupyter notebook as expected. If you're facing difficulties with this, you may want to consider creating a separate web application for the visual decision tree and embedding it in your notebook as an iframe, as mentioned in the previous messages.\n",
    "\n",
    "If you'd like to go down the iframe route, here are the steps you might take:\n",
    "\n",
    "Create a separate web application for the visual decision tree. You'd use vis.js in this application to create the network diagram.\n",
    "\n",
    "Serve the web application from a local server. This would allow you to access the application via a URL.\n",
    "\n",
    "Embed the web application in your Jupyter Notebook. You'd use an iframe to embed the URL of your web application in the notebook.\n",
    "\n",
    "Communicate between the notebook and the web application. You'd use the\n",
    "\n",
    "User im okay with having a separate web application for controller the visual decision tree. react would be preferable. ChatGPT Great, React is a powerful library for building user interfaces and it's a good choice for this application. Here's a high-level blueprint of how you might create a React application to control your visual decision tree:\n",
    "\n",
    "Setup Your React Project: You can create a new React project using Create React App: bash Copy code npx create-react-app tech-tree-controller Install Necessary Libraries: You will need vis.js for the network diagram and axios (or fetch) for making HTTP requests to your Jupyter notebook: bash Copy code npm install vis-network axios Create Network Diagram with vis.js: Here is a very basic example of how you might integrate a network diagram with React: jsx Copy code import React, { useEffect, useRef } from \"react\"; import { DataSet, Network } from \"vis-network\";\n",
    "\n",
    "const TechTree = ({ nodes, edges }) => { const containerRef = useRef(null);\n",
    "\n",
    "useEffect(() => { if (containerRef.current && nodes && edges) { const data = { nodes: new DataSet(nodes), edges: new DataSet(edges), }; new Network(containerRef.current, data, {}); } }, [nodes, edges]);\n",
    "\n",
    "return\n",
    "\n",
    "; };\n",
    "export default TechTree; In this component, you pass nodes and edges as props, and use them to create a vis-network instance inside a useEffect hook. nodes and edges should be arrays of objects, where each object represents"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "58de4567",
   "metadata": {},
   "source": [
    " a node or an edge in the network diagram.\n",
    "\n",
    "Make HTTP Requests to Jupyter Notebook: You can use axios to make HTTP requests to your Jupyter notebook API to execute code, get chatbot responses, and update your diagram. Here's a basic example of how you might use axios to make a request: jsx Copy code axios.post('http://localhost:8888/execute', { code: 'print(\"Hello, world!\")' }) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); Please note, you will have to setup an API in your Jupyter notebook to handle these HTTP requests.\n",
    "\n",
    "Render the TechTree Component: Finally, you can use the TechTree component in your application: jsx Copy code function App() { const nodes = [ { id: \"1\", label: \"Node 1\" }, { id: \"2\", label: \"Node 2\" }, { id: \"3\", label: \"Node 3\" }, ];\n",
    "\n",
    "const edges = [ { from: \"1\", to: \"2\" }, { from: \"1\", to: \"3\" }, ];\n",
    "\n",
    "return (\n",
    "\n",
    "); }\n",
    "export default App; Please note that this is a very basic and simplified example, and you will have to build upon it to create a fully functioning tech tree controller. It also assumes that you have a way of interfacing with your Jupyter notebook via HTTP requests, which would require additional setup.\n",
    "\n",
    "User next ChatGPT Once you have your React application setup and a basic network diagram showing, you'll want to make it interactive and connected to your Jupyter notebook. Here are the next steps:\n",
    "\n",
    "Handling Node Selection: Add event listeners to handle node selection in your tech tree. This could trigger an HTTP request to your Jupyter notebook to execute a specific code based on the selected node. jsx Copy code useEffect(() => { if (containerRef.current && nodes && edges) { const data = { nodes: new DataSet(nodes), edges: new DataSet(edges), }; const network = new Network(containerRef.current, data, {});\n",
    "\n",
    "  network.on(\"selectNode\", function (params) {\n",
    "    console.log(\"selected node\", params.nodes[0]);\n",
    "    // Here you can trigger an HTTP request to your notebook\n",
    "  });\n",
    "}\n",
    "}, [nodes, edges]); Updating the Diagram Dynamically: You might want to update your diagram based on the responses from your Jupyter notebook. For this, you can store your nodes and edges in a state using the useState hook and update them when you get a response. jsx Copy code const [nodes, setNodes] = useState([]); const [edges, setEdges] = useState([]);\n",
    "\n",
    "useEffect(() => { axios.get('http://localhost:8888/get-branches') .then(function (response) { setNodes(response.data.nodes); setEdges(response.data.edges); }) .catch(function (error) { console.error(error); }); }, []); In this example, you would need an endpoint in your Jupyter notebook that returns the current branches (nodes and edges) in the format expected by vis.js.\n",
    "\n",
    "**Communicating\n",
    "\n",
    "User lets do this. lets start with having the jupyter parse the chatbot's responses in teh jupyter notebook. from there, it should be able to find function, filename, and linenumber ChatGPT To parse the chatbot's responses in the Jupyter notebook, you can use a combination of techniques including regular expressions and natural language processing. The exact method you use will depend on the format of the chatbot's responses.\n",
    "\n",
    "Below is an example of how you might extract function names, filenames, and line numbers from a string using regular expressions in JavaScript:\n",
    "\n",
    "javascript Copy code let response = \"Error at function: functionName, in file: fileName.js, line number: 42\"; let functionPattern = /function: (\\w+)/; let filePattern = /file: (\\w+.\\w+)/; let linePattern = /line number: (\\d+)/;\n",
    "\n",
    "let functionName = response.match(functionPattern)[1]; let fileName = response.match(filePattern)[1]; let lineNumber = response.match(linePattern)[1];\n",
    "\n",
    "console.log(functionName); // \"functionName\" console.log(fileName); // \"fileName.js\" console.log(lineNumber); // \"42\" In this example, we define three regular expressions to match the function name, filename, and line number in the response. We then use the match function to extract these values from the response.\n",
    "\n",
    "For more complex responses, you may need to use a natural language processing library to parse the response. There are many such libraries available in both JavaScript and Python, including spaCy, NLTK, and Natural.\n",
    "\n",
    "If you're using Python in your Jupyter notebook, you can use similar regular expressions with Python's re module:\n",
    "\n",
    "python Copy code import re\n",
    "\n",
    "response = \"Error at function: functionName, in file: fileName.py, line number: 42\" function_pattern = r\"function: (\\w+)\" file_pattern = r\"file: (\\w+.\\w+)\" line_pattern = r\"line number: (\\d+)\"\n",
    "\n",
    "function_name = re.search(function_pattern, response).group(1) file_name = re.search(file_pattern, response).group(1) line_number = re.search(line_pattern, response).group(1)\n",
    "\n",
    "print(function_name) # \"functionName\" print(file_name) # \"fileName.py\" print(line_number) # \"42\" You can then use these extracted values to update your visual decision tree. For example, you could add a new node for the function, with an edge from the file node to the function node. You could also add metadata to the node indicating the line number.\n",
    "\n",
    "chat\n",
    "format this block of text and tell me where we are in theis project. what do i need to provide.\n",
    "\n",
    "Fantastic! It sounds like you're already off to a great start. Let's continue with step 4 then.\n",
    "\n",
    "Design Visual Decision Tree:\n",
    "\n",
    "A library like vis.js can be very useful for creating interactive, dynamic network diagrams that could serve as your decision tree. However, it's worth noting that vis.js is a JavaScript library, and using it directly in a Jupyter Notebook running with an iJavascript kernel might have its challenges, as the notebook environment isn't designed to handle complex web visualizations."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2c52458a",
   "metadata": {},
   "source": [
    "Here's a basic example of how you might start creating a network diagram with vis.js:\n",
    "\n",
    "javascript Copy code var nodes = [ {id: 1, label: 'Node 1'}, {id: 2, label: 'Node 2'}, {id: 3, label: 'Node 3'}, {id: 4, label: 'Node 4'}, {id: 5, label: 'Node 5'} ];\n",
    "\n",
    "// create an array with edges var edges = [ {from: 1, to: 2}, {from: 1, to: 3}, {from: 2, to: 4}, {from: 2, to: 5} ];\n",
    "\n",
    "// create a network var container = document.getElementById('mynetwork'); var data = { nodes: nodes, edges: edges }; var options = {}; var network = new vis.Network(container, data, options); In this example, you'd need to replace the static nodes and edges with dynamic ones based on the responses from the chatbot.\n",
    "\n",
    "However, it's important to consider that running this kind of JavaScript code might not work in a Jupyter notebook as expected. If you're facing difficulties with this, you may want to consider creating a separate web application for the visual decision tree and embedding it in your notebook as an iframe, as mentioned in the previous messages.\n",
    "\n",
    "If you'd like to go down the iframe route, here are the steps you might take:\n",
    "\n",
    "Create a separate web application for the visual decision tree. You'd use vis.js in this application to create the network diagram.\n",
    "\n",
    "Serve the web application from a local server. This would allow you to access the application via a URL.\n",
    "\n",
    "Embed the web application in your Jupyter Notebook. You'd use an iframe to embed the URL of your web application in the notebook.\n",
    "\n",
    "Communicate between the notebook and the web application. You'd use the\n",
    "\n",
    "User im okay with having a separate web application for controller the visual decision tree. react would be preferable. ChatGPT Great, React is a powerful library for building user interfaces and it's a good choice for this application. Here's a high-level blueprint of how you might create a React application to control your visual decision tree:\n",
    "\n",
    "Setup Your React Project: You can create a new React project using Create React App: bash Copy code npx create-react-app tech-tree-controller Install Necessary Libraries: You will need vis.js for the network diagram and axios (or fetch) for making HTTP requests to your Jupyter notebook: bash Copy code npm install vis-network axios Create Network Diagram with vis.js: Here is a very basic example of how you might integrate a network diagram with React: jsx Copy code import React, { useEffect, useRef } from \"react\"; import { DataSet, Network } from \"vis-network\";\n",
    "\n",
    "const TechTree = ({ nodes, edges }) => { const containerRef = useRef(null);\n",
    "\n",
    "useEffect(() => { if (containerRef.current && nodes && edges) { const data = { nodes: new DataSet(nodes), edges: new DataSet(edges), }; new Network(containerRef.current, data, {}); } }, [nodes, edges]);\n",
    "\n",
    "return\n",
    "\n",
    "; };\n",
    "export default TechTree; In this component, you pass nodes and edges as props, and use them to create a vis-network instance inside a useEffect hook. nodes and edges should be arrays of objects, where each object represents a node or an edge in the network diagram.\n",
    "\n",
    "Make HTTP Requests to Jupyter Notebook: You can use axios to make HTTP requests to your Jupyter notebook API to execute code, get chatbot responses, and update your diagram. Here's a basic example of how you might use axios to make a request: jsx Copy code axios.post('http://localhost:8888/execute', { code: 'print(\"Hello, world!\")' }) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); Please note, you will have to setup an API in your Jupyter notebook to handle these HTTP requests.\n",
    "\n",
    "Render the TechTree Component: Finally, you can use the TechTree component in your application: jsx Copy code function App() { const nodes = [ { id: \"1\", label: \"Node 1\" }, { id: \"2\", label: \"Node 2\" }, { id: \"3\", label: \"Node 3\" }, ];\n",
    "\n",
    "const edges = [ { from: \"1\", to: \"2\" }, { from: \"1\", to: \"3\" }, ];\n",
    "\n",
    "return (\n",
    "\n",
    "); }\n",
    "export default App; Please note that this is a very basic and simplified example, and you will have to build upon it to create a fully functioning tech tree controller. It also assumes that you have a way of interfacing with your Jupyter notebook via HTTP requests, which would require additional setup.\n",
    "\n",
    "User next ChatGPT Once you have your React application setup and a basic network diagram showing, you'll want to make it interactive and connected to your Jupyter notebook. Here are the next steps:\n",
    "\n",
    "Handling Node Selection: Add event listeners to handle node selection in your tech tree. This could trigger an HTTP request to your Jupyter notebook to execute a specific code based on the selected node. jsx Copy code useEffect(() => { if (containerRef.current && nodes && edges) { const data = { nodes: new DataSet(nodes), edges: new DataSet(edges), }; const network = new Network(containerRef.current, data, {});\n",
    "\n",
    "  network.on(\"selectNode\", function (params) {\n",
    "    console.log(\"selected node\", params.nodes[0]);\n",
    "    // Here you can trigger an HTTP request to your notebook\n",
    "  });\n",
    "}\n",
    "}, [nodes, edges]); Updating the Diagram Dynamically: You might want to update your diagram based on the responses from your Jupyter notebook. For this, you can store your nodes and edges in a state using the useState hook and update them when you get a response. jsx Copy code const [nodes, setNodes] = useState([]); const [edges, setEdges] = useState([]);\n",
    "\n",
    "useEffect(() => { axios.get('http://localhost:8888/get-branches') .then(function (response) { setNodes(response.data.nodes); setEdges(response.data.edges); }) .catch(function (error) { console.error(error); }); }, []); In this example, you would need an endpoint in your Jupyter notebook that returns the current branches (nodes and edges) in the format expected by vis.js.\n",
    "\n",
    "**Communicating\n",
    "\n",
    "User lets do this. lets start with having the jupyter parse the chatbot's responses in teh jupyter notebook. from there, it should be able to find function, filename, and linenumber ChatGPT To parse the chatbot's responses in the Jupyter notebook, you can use a combination of techniques including regular expressions and natural language processing. The exact method you use will depend on the format of the chatbot's responses.\n",
    "\n",
    "Below is an example of how you might extract function names, filenames, and line numbers from a string using regular expressions in JavaScript:\n",
    "\n",
    "javascript Copy code let response = \"Error at function: functionName, in file: fileName.js, line number: 42\"; let functionPattern = /function: (\\w+)/; let filePattern = /file: (\\w+.\\w+)/; let linePattern = /line number: (\\d+)/;\n",
    "\n",
    "let functionName = response.match(functionPattern)[1]; let fileName = response.match(filePattern)[1]; let lineNumber = response.match(linePattern)[1];\n",
    "\n",
    "console.log(functionName); // \"functionName\" console.log(fileName); // \"fileName.js\" console.log(lineNumber); // \"42\" In this example, we define three regular expressions to match the function name, filename, and line number in the response. We then use the match function to extract these values from the response.\n",
    "\n",
    "For more complex responses, you may need to use a natural language processing library to parse the response. There are many such libraries available in both JavaScript and Python, including spaCy, NLTK, and Natural.\n",
    "\n",
    "If you're using Python in your Jupyter notebook, you can use similar regular expressions with Python's re module:\n",
    "\n",
    " You can then use these extracted values to update your visual decision tree. For example, you could add a new node for the function, with an edge from the file node to the function node. You could also add metadata to the node indicating the line number.\n",
    "\n",
    "chat\n",
    "whats next?\n",
    "\n",
    "response generated by ChatGPT in "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8fbf24b4",
   "metadata": {},
   "source": [
    "4 seconds at 5/21/2023 10:08:06 PM\n",
    "Next, after parsing the chatbot's responses in the Jupyter notebook and extracting the function name, filename, and line number, you can update your visual decision tree to reflect this information. Here are the next steps:\n",
    "1. Update the Nodes and Edges: Create a new node for the extracted function and an edge connecting it to the corresponding file node in your visual decision tree. You can use the extracted values (function name, filename, line number) to define the properties of the new node.\n",
    "2. Update the State and Re-Render: If you're using React, you can use the useState hook to maintain the state of your nodes and edges. Update the state with the new node and edge, and the React component will re-render with the updated visual decision tree.\n",
    "3. Display the Updated Tree: Ensure that the updated visual decision tree is displayed in your separate web application. You can use the TechTree component (or a similar component) to render the updated tree based on the updated state.\n",
    "4. Repeat for Each Response: Repeat the process for each response from the chatbot. Parse the response, extract the relevant information, update the visual decision tree, update the state, and re-render the component.\n",
    "Remember to handle any error cases or edge scenarios that may arise during the process, such as handling responses that do not contain the expected information or handling duplicate nodes.\n",
    "By following these steps, you'll be able to dynamically update your visual decision tree based on the chatbot's responses in the Jupyter notebook.\n",
    "Next, after parsing the chatbot's responses in the Jupyter notebook and extracting the function name, filename, and line number, you can update your visual decision tree to reflect this information. Here are the next steps:\n",
    "1. Update the Nodes and Edges: Create a new node for the extracted function and an edge connecting it to the corresponding file node in your visual decision tree. You can use the extracted values (function name, filename, line number) to define the properties of the new node.\n",
    "2. Update the State and Re-Render: If you're using React, you can use the useState hook to maintain the state of your nodes and edges. Update the state with the new node and edge, and the React component will re-render with the updated visual decision tree.\n",
    "3. Display the Updated Tree: Ensure that the updated visual decision tree is displayed in your separate web application. You can use the TechTree component (or a similar component) to render the updated tree based on the updated state.\n",
    "4. Repeat for Each Response: Repeat the process for each response from the chatbot. Parse the response, extract the relevant information, update the visual decision tree, update the state, and re-render the component.\n",
    "Remember to handle any error cases or edge scenarios that may arise during the process, such as handling responses that do not contain the expected information or handling duplicate nodes.\n",
    "By following these steps, you'll be able to dynamically update your visual decision tree based on the chatbot's responses in the Jupyter notebook.\n",
    "chat\n",
    "walk me thru it\n",
    "\n",
    "response generated by ChatGPT in 7 seconds at 5/21/2023 10:09:02 PM\n",
    "Sure! Here's a walkthrough of the steps involved in updating your visual decision tree based on the chatbot's responses in the Jupyter notebook:\n",
    "1. Parsing the Chatbot's Responses: In the Jupyter notebook, you'll need to parse the chatbot's responses to extract the function name, filename, and line number. This can be done using regular expressions or natural language processing techniques, depending on the format of the responses.\n",
    "2. Update Nodes and Edges: Once you have extracted the relevant information, create a new node for the function and an edge connecting it to the corresponding file node in your visual decision tree. Use the extracted values to define the properties of the new node, such as the function name, filename, and line number.\n",
    "3. Update State and Re-Render: If you're using React, maintain the state of your nodes and edges using the useState hook. Update the state with the new node and edge information. When the state is updated, the React component will re-render with the updated visual decision tree.\n",
    "4. Display the Updated Tree: Ensure that the updated visual decision tree is displayed in your separate web application. You can use the TechTree component (or a similar component) to render the updated tree based on the updated state. This will show the new function node and the edge connecting it to the file node.\n",
    "5. Repeat for Each Response: Repeat the process for each response from the chatbot. Parse the response, extract the relevant information, update the visual decision tree, update the state, and re-render the component. This way, the tree will dynamically grow and reflect the information from each chatbot response.\n",
    "Throughout the process, make sure to handle any error cases or edge scenarios that may arise. For example, handle responses that do not contain the expected information gracefully and avoid creating duplicate nodes in your tree.\n",
    "By following these steps, you'll be able to effectively update your visual decision tree based on the chatbot's responses in the Jupyter notebook.\n",
    "Sure! Here's a walkthrough of the steps involved in upd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "105879c8",
   "metadata": {},
   "source": [
    "ating your visual decision tree based on the chatbot's responses in the Jupyter notebook:\n",
    "1. Parsing the Chatbot's Responses: In the Jupyter notebook, you'll need to parse the chatbot's responses to extract the function name, filename, and line number. This can be done using regular expressions or natural language processing techniques, depending on the format of the responses.\n",
    "2. Update Nodes and Edges: Once you have extracted the relevant information, create a new node for the function and an edge connecting it to the corresponding file node in your visual decision tree. Use the extracted values to define the properties of the new node, such as the function name, filename, and line number.\n",
    "3. Update State and Re-Render: If you're using React, maintain the state of your nodes and edges using the useState hook. Update the state with the new node and edge information. When the state is updated, the React component will re-render with the updated visual decision tree.\n",
    "4. Display the Updated Tree: Ensure that the updated visual decision tree is displayed in your separate web application. You can use the TechTree component (or a similar component) to render the updated tree based on the updated state. This will show the new function node and the edge connecting it to the file node.\n",
    "5. Repeat for Each Response: Repeat the process for each response from the chatbot. Parse the response, extract the relevant information, update the visual decision tree, update the state, and re-render the component. This way, the tree will dynamically grow and reflect the information from each chatbot response.\n",
    "Throughout the process, make sure to handle any error cases or edge scenarios that may arise. For example, handle responses that do not contain the expected information gracefully and avoid creating duplicate nodes in your tree.\n",
    "By following these steps, you'll be able to effectively update your visual decision tree based on the chatbot's responses in the Jupyter notebook.\n",
    "I apologize for the confusion, but it seems there is no specific code block or code path mentioned in the conversation so far. Could you please provide more context or specify which code path you would like me to assist you with?\n",
    "response generated by ChatGPT in 4 seconds at 5/21/2023 9:43:41 PM\n",
    "To summarize the progress of the project:\n",
    "1. You have decided to create a separate web application for the visual decision tree using React.\n",
    "2. The React application will use the vis.js library for creating the network diagram.\n",
    "3. You will need to set up the React project using Create React App and install the necessary libraries (vis-network and axios).\n",
    "4. You have a basic TechTree component in React that integrates the network diagram using vis-network.\n",
    "5. You can make HTTP requests from the React application to your Jupyter notebook using axios for executing code and obtaining responses.\n",
    "6. You can render the TechTree component in your React application and pass nodes and edges as props to display a basic network diagram.\n",
    "7. Next steps involve making the diagram interactive by handling node selection and updating the diagram dynamically based on responses from the Jupyter notebook.\n",
    "8. To parse the chatbot's responses in the Jupyter notebook, you can use regular expressions and/or natural language processing techniques to extract function names, filenames, and line numbers.\n",
    "9. The extracted values can then be used to update the visual decision tree by adding new nodes and edges representing the functions and their relationships.\n",
    "To proceed further, you should provide the chatbot's responses and the specific format they are in, so that appropriate parsing techniques can be implemented in the Jupyter notebook.\n",
    "chat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a5ba4379",
   "metadata": {},
   "outputs": [],
   "source": [
    "python Copy code import re\n",
    "\n",
    "response = \"Error at function: functionName, in file: fileName.py, line number: 42\" function_pattern = r\"function: (\\w+)\" file_pattern = r\"file: (\\w+.\\w+)\" line_pattern = r\"line number: (\\d+)\"\n",
    "\n",
    "function_name = re.search(function_pattern, response).group(1) file_name = re.search(file_pattern, response).group(1) line_number = re.search(line_pattern, response).group(1)\n",
    "\n",
    "print(function_name) # \"functionName\" print(file_name) # \"fileName.py\" print(line_number) # \"42\""
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
